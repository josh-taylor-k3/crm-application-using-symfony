{% extends '@WebProfiler/Profiler/layout.html.twig' %}

{% from _self import display_timeline, dump_request_data %}

{% if colors is not defined %}
    {% set colors = {
        'default':                '#aacd4e',
        'section':                '#666',
        'event_listener':         '#3dd',
        'event_listener_loading': '#add',
        'template':               '#dd3',
        'doctrine':               '#d3d',
        'propel':                 '#f4d',
        'child_sections':         '#eed',
    } %}
{% endif %}

{% block toolbar %}
    {% set duration = collector.events|length ? '%.0f ms'|format(collector.duration) : 'n/a' %}
    {% set icon %}
        <img width="16" height="28" class="hover-icon" alt="Time" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAcCAMAAABbGh8VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MUJDQkVGNzk1REFGMTFFMzgxOThBMkYzODg3NTk0M0UiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MUJDQkVGN0E1REFGMTFFMzgxOThBMkYzODg3NTk0M0UiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxQkNCRUY3NzVEQUYxMUUzODE5OEEyRjM4ODc1OTQzRSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxQkNCRUY3ODVEQUYxMUUzODE5OEEyRjM4ODc1OTQzRSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PotZR2QAAAECUExURc3Nzf///////////////////////////////////////////6ioqP///////5ubm7S0tKKiov///////////////////////////2ZmZv///////////////2NjY////////4+Pj////////////////319ff///+/v7////////////+Xl5fHx8b29vVBQUOXl5VBQUE5OTllZWf///////6qqqk5OTmFhYfHx8e7u7lNTU1tbW0xMTMLCwri4uHR0dEhISGtra3h4eENDQ0NDQ01NTWhoaHV1dT8/P1BQUG1tbXZ2dl9fX3R0dENDQ1ZWVkJCQkRERD8/P0REREZGRmaOzvgAAABTdFJOUwAAAQIDBAULDA0PEBQUFRcXHyorLC8zPD1AQkRFRkpKS1JdYmZnao+Qk5WWnqGmqK2vs7S0tre9wcXGyc/U2Nzg4+nr7O/w8/b39/j4+fn7/P39uCLJBgAAAMlJREFUKM+d0dduwkAQBVB7sQkQek3oJfReQi8h9F4G/v9XGFe8QkKI+7I7R9qHucuwD2HeJ0bMCiPdnpH8RiU+XJsBTMvfnEzE1gI5VTMRiDjGoGZgJ0jGnjiwrHjUP5BSoCWIIfVpaiMdaJojgUKspI90QjoDlTXSP01/SE2aSkjJhVYmcSRv4XiXXcaNZIpUNoosi36DsLYlmhvtLwDX7TAd+BTWZnQm70/+t9tpZBMeI5Er1FtdX6Ggz2nhtUUTjiNq96/84w0R7UUpX7UxmwAAAABJRU5ErkJggg==">
        <img width="16" height="28" style="display: none;"  class="active-icon" alt="Time" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAcCAYAAABsxO8nAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDFCQkIzRkU1REFFMTFFMzgwNDM5NEQwRjVCMkJFREUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDFCQkIzRkY1REFFMTFFMzgwNDM5NEQwRjVCMkJFREUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpEMUJCQjNGQzVEQUUxMUUzODA0Mzk0RDBGNUIyQkVERSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpEMUJCQjNGRDVEQUUxMUUzODA0Mzk0RDBGNUIyQkVERSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj5U7kUAAAJhSURBVHjazJVNaxNBGMd3NtltNk1i+mJbW7QgUnoRT3ryoCCeFC9+hF705l0Qv4QIHntQPFns1V62CCJWkbYeglpTYmLed7Mvyeyb/1nTzTZNkzT04MBDmJ2Z3zwv/2dCLl2+xp3G4LlTGv8fKNpv8emzdTM8f/LwjjQSyLZobFiPyICqmV3z4T1COOzbbdgDWBOWbi9VYK9gz2EywnR6egQAwc+M53kvCSE3+7mJPWvYs8LgAHpB1RgE+Vh0XffzIIh/OyH3XNeRKW3Oth34BzL1RhLYNzzPn+s+hBt9O6IbPrJMOLKqa8p4WEcrgiBeOc6Bth0Zgjh2C7C7AQhuPhpViDj7OABJ46mFUUFiTFoKyo/ckEEHwnlCgjsgMRYdqOweuQoUEJJCR5BsgpIe129eP7pjW53uNzRl5K7XG0pHkH9ye3RU0O9sxghAe5ntDG01TwwxNJXL/cp8DUANpbK2++W9hRYZGuLYNre9JZtqvfKWzSOTswucOCY5Fm1dQNIvTkzPEci/L8SyKLezJbv7P76tV4q5VbVWzvmglmmwbDdMXZ3XNXVeiid4wJm+Dj90qFC1lOd2Psl29vvuRjGffVErFz7CCeqXv2nqSq2c32g1DRdx3y8X9m9Mz52fSk+e5WNSwpeNaWhcvVp0sFaqlgrvlGrxNcKScVbrfiHZ9clEKr2cSE1cl+LJq5D/YiQSPcNI0IuCgvw0dPVDQ6lu4sIMvmsH4uz11ArtV3EGuZqKRoU424ywDDQoeyWLsDqLdNDjz6RaYoaDhFLnIFFuuDVO9C/SPugMI4e/AgwA780aUB6QgkEAAAAASUVORK5CYII=">
        <span>{{ duration }}</span>
    {% endset %}
    {% set text %}
        <div class="sf-toolbar-info-piece">
            <b>Total time</b>
            <span>{{ duration }}</span>
        </div>
    {% endset %}
    {% include '@WebProfiler/Profiler/toolbar_item.html.twig' with { 'link': profiler_url } %}
{% endblock %}

{% block menu %}
<span class="label">
    <span class="icon"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAhCAYAAADOHBvaAAACz0lEQVR42t2XXWhSYRjHc+pyWrC10e66qKggiGoF0Qh1SBPFDxCcX00yrG6EImFsRhAuvUjwQgZB1EUICYEkgRJGB0QmKMNGEYx1URYEg2w6amWY/YUXXH7Ms9M5RAk/PByf8/58P573ec+2Wq32V/g3xFKpdB3UQBV8JVTJvXUuxbXN+P96TODNzMzsNJvNo3UCgYCYszmmKKrPYrE4NBrNU7lcvtY8xGNjYyWtVvvEZrPZES9kQyy02+3nx8fH3xFJV5RK5RuHw2GqP8tInEgk+g0GwyN6wlZMJtPdfD6/Y0viVCo1iKHLMpM20Ov1FNqT0BWLsWhiXdImDyiQ7ybHVN1HnKibWHgNHxr5egXI6t90ej49PX0BsYKO4qWlpT1qtXqFhlhGnpHREWPaPiB2dydxL/7ZTRLMnpjg8/lcpNct4mGr1fqSK7HT6UwhfleLuFwuH1EoFBWuxDqd7jPiDzSLe+Lx+AQJYl9MKBQKZ+pb7kaxKBKJXGUgPgqCgGrQOc3S6fQEfuNvFEtisdgUA3E/kcsadE6zhYUFG9lKG2LcvMxA3EKnKUBx+bm6uqptFvcCtUql+kECWcdoNH6BQw56fltcYNTtdr/nSuzxeJbhONkujw9Fo9EYV+JkMvkAjv3txEOVSuUSytk3tqWoz2to/xwYaCcWgtPI5+dsSrGo6mn0GG2PtG6ZDYbBRb/f/5EtcSgUeos2J8HgpmURHMaQz6JglP5U6vV6P6G962Sr5HcUE/rAKXB7bm5uhenwhsPheim8BUa6HwQaSMjSv5HNZl+gstDOb5fL9X1xcTGLZ6fAMSDe6ilTBA4CO7iXyWReB4PBMo5F1WYZymkVc1nK5XKvEHsHWMA+sJ3p8VYAhkjvJ4EPRMCzYrE4XyqV5nGdBA/BLLCC46Tu8tl4kxCAAdKLE0AGzhKkZB73kqIh4PI1lQf4BB6TNn4B8KR3FN9bp4MAAAAASUVORK5CYII=" alt="Timeline"></span>
    <strong>Timeline</strong>
</span>
{% endblock %}

{% block panel %}
    <h2>Timeline</h2>
    {% if collector.events|length %}
        {{ block('panelContent') }}
    {% else %}
        <p>
            <em>No timing events have been recorded. Are you sure that debugging is enabled in the kernel?</em>
        </p>
    {% endif %}
{% endblock %}

{% block panelContent %}
    <form id="timeline-control" action="" method="get">
        <input type="hidden" name="panel" value="time">
        <table>
            <tr>
                <th style="width: 20%">Total time</th>
                <td>{{ '%.0f'|format(collector.duration) }} ms</td>
            </tr>
            <tr>
                <th>Initialization time</th>
                <td>{{ '%.0f'|format(collector.inittime) }} ms</td>
            </tr>
            <tr>
                <th>Threshold</th>
                <td><input type="number" size="3" name="threshold" value="1" min="0"> ms</td>
            </tr>
        </table>
    </form>

    <h3>
        {{ profile.parent ? "Request" : "Main Request" }}
        <small>
            - {{ collector.events.__section__.duration }} ms
            {% if profile.parent %}
                - <a href="{{ path('_profiler', { 'token': profile.parent.token, 'panel': 'time' }) }}">parent</a>
            {% endif %}
        </small>
    </h3>

    {{ display_timeline('timeline_' ~ token, collector.events, colors) }}

    {% if profile.children|length %}
        {% for child in profile.children %}
            {% set events = child.getcollector('time').events %}
            <h3>
                Sub-request "<a href="{{ path('_profiler', { 'token': child.token, 'panel': 'time' }) }}">{{ child.getcollector('request').requestattributes.get('_controller') }}</a>"
                <small> - {{ events.__section__.duration }} ms</small>
            </h3>

            {{ display_timeline('timeline_' ~ child.token, events, colors) }}
        {% endfor %}
    {% endif %}

    <script>//<![CDATA[
        /**
         * In-memory key-value cache manager
         */
        var cache = new function() {
            "use strict";
            var dict = {};

            this.get = function(key) {
                return dict.hasOwnProperty(key)
                    ? dict[key]
                    : null;
                }

            this.set = function(key, value) {
                dict[key] = value;

                return value;
            }
        };

        /**
         * Query an element with a CSS selector.
         *
         * @param  string selector a CSS-selector-compatible query string.
         *
         * @return DOMElement|null
         */
        function query(selector)
        {
            "use strict";
            var key = 'SELECTOR: ' + selector;

            return cache.get(key) || cache.set(key, document.querySelector(selector));
        }

        /**
         * Canvas Manager
         */
        function CanvasManager(requests, maxRequestTime) {
            "use strict";

            var _drawingColors  = {{ colors|json_encode|raw }},
                _storagePrefix  = 'timeline/',
                _threshold      = 1,
                _requests       = requests,
                _maxRequestTime = maxRequestTime;

            /**
             * Check whether this event is a child event.
             *
             * @return true if it is.
             */
            function isChildEvent(event)
            {
                return '__section__.child' === event.name;
            }

            /**
             * Check whether this event is categorized in 'section'.
             *
             * @return true if it is.
             */
            function isSectionEvent(event)
            {
                return 'section' === event.category;
            }

            /**
             * Get the width of the container.
             */
            function getContainerWidth()
            {
                return query('#collector-content h2').clientWidth;
            }

            /**
             * Draw one canvas.
             *
             * @param request   the request object
             * @param max       <subjected for removal>
             * @param threshold the threshold (lower bound) of the length of the timeline (in milliseconds).
             * @param width     the width of the canvas.
             */
            this.drawOne = function(request, max, threshold, width)
            {
                "use strict";
                var text,
                    ms,
                    xc,
                    drawableEvents,
                    mainEvents,
                    elementId    = 'timeline_' + request.id,
                    canvasHeight = 0,
                    gapPerEvent  = 38,
                    colors = _drawingColors,
                    space  = 10.5,
                    ratio  = (width - space * 2) / max,
                    h = space,
                    x = request.left * ratio + space, // position
                    canvas = cache.get(elementId) || cache.set(elementId, document.getElementById(elementId)),
                    ctx    = canvas.getContext("2d"),
                    backingStoreRatio,
                    scaleRatio,
                    devicePixelRatio;

                // Filter events whose total time is below the threshold.
                drawableEvents = request.events.filter(function(event) {
                    return event.duration >= threshold;
                });

                canvasHeight += gapPerEvent * drawableEvents.length;

                // For retina displays so text and boxes will be crisp
                devicePixelRatio  = window.devicePixelRatio          == "undefined" ? 1 : window.devicePixelRatio;
                backingStoreRatio = ctx.webkitBackingStorePixelRatio == "undefined" ? 1 : ctx.webkitBackingStorePixelRatio;
                scaleRatio        = devicePixelRatio / 1;

                canvasHeight += gapPerEvent * drawableEvents.length;

                canvas.width  = width * scaleRatio;
                canvas.height = canvasHeight * scaleRatio;

                canvas.style.width = width + 'px';
                canvas.style.height = canvasHeight + 'px';

                ctx.scale(scaleRatio, scaleRatio);

                ctx.textBaseline = "middle";
                ctx.lineWidth = 0;

                // For each event, draw a line.
                ctx.strokeStyle = "#dfdfdf";

                drawableEvents.forEach(function(event) {
                    event.periods.forEach(function(period) {
                        var timelineHeadPosition = x + period.start * ratio;

                        if (isChildEvent(event)) {
                            ctx.fillStyle = colors.child_sections;
                            ctx.fillRect(timelineHeadPosition, 0, (period.end - period.start) * ratio, canvasHeight);
                        } else if (isSectionEvent(event)) {
                            var timelineTailPosition = x + period.end * ratio;

                            ctx.beginPath();
                            ctx.moveTo(timelineHeadPosition, 0);
                            ctx.lineTo(timelineHeadPosition, canvasHeight);
                            ctx.moveTo(timelineTailPosition, 0);
                            ctx.lineTo(timelineTailPosition, canvasHeight);
                            ctx.fill();
                            ctx.closePath();
                            ctx.stroke();
                        }
                    });
                });

                // Filter for main events.
                mainEvents = drawableEvents.filter(function(event) {
                    return !isChildEvent(event)
                });

                // For each main event, draw the visual presentation of timelines.
                mainEvents.forEach(function(event) {

                    h += 8;

                    // For each sub event, ...
                    event.periods.forEach(function(period) {
                        // Set the drawing style.
                        ctx.fillStyle   = colors['default'];
                        ctx.strokeStyle = colors['default'];

                        if (colors[event.name]) {
                            ctx.fillStyle   = colors[event.name];
                            ctx.strokeStyle = colors[event.name];
                        } else if (colors[event.category]) {
                            ctx.fillStyle   = colors[event.category];
                            ctx.strokeStyle = colors[event.category];
                        }

                        // Draw the timeline
                        var timelineHeadPosition = x + period.start * ratio;

                        if (!isSectionEvent(event)) {
                            ctx.fillRect(timelineHeadPosition, h + 3, 2, 6);
                            ctx.fillRect(timelineHeadPosition, h, (period.end - period.start) * ratio || 2, 6);
                        } else {
                            var timelineTailPosition = x + period.end * ratio;

                            ctx.beginPath();
                            ctx.moveTo(timelineHeadPosition, h);
                            ctx.lineTo(timelineHeadPosition, h + 11);
                            ctx.lineTo(timelineHeadPosition + 8, h);
                            ctx.lineTo(timelineHeadPosition, h);
                            ctx.fill();
                            ctx.closePath();
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(timelineTailPosition, h);
                            ctx.lineTo(timelineTailPosition, h + 11);
                            ctx.lineTo(timelineTailPosition - 8, h);
                            ctx.lineTo(timelineTailPosition, h);
                            ctx.fill();
                            ctx.closePath();
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(timelineHeadPosition, h);
                            ctx.lineTo(timelineTailPosition, h);
                            ctx.lineTo(timelineTailPosition, h + 2);
                            ctx.lineTo(timelineHeadPosition, h + 2);
                            ctx.lineTo(timelineHeadPosition, h);
                            ctx.fill();
                            ctx.closePath();
                            ctx.stroke();
                        }
                    });

                    h += 30;

                    ctx.beginPath();
                    ctx.strokeStyle = "#dfdfdf";
                    ctx.moveTo(0, h - 10);
                    ctx.lineTo(width, h - 10);
                    ctx.closePath();
                    ctx.stroke();
                });

                h = space;

                // For each event, draw the label.
                mainEvents.forEach(function(event) {

                    ctx.fillStyle = "#444";
                    ctx.font = "12px sans-serif";
                    text = event.name;
                    ms = " ~ " + (event.duration < 1 ? event.duration : parseInt(event.duration, 10)) + " ms / ~ " + event.memory + " MB";
                    if (x + event.starttime * ratio + ctx.measureText(text + ms).width > width) {
                        ctx.textAlign = "end";
                        ctx.font = "10px sans-serif";
                        xc = x + event.endtime * ratio - 1;
                        ctx.fillText(ms, xc, h);

                        xc -= ctx.measureText(ms).width;
                        ctx.font = "12px sans-serif";
                        ctx.fillText(text, xc, h);
                    } else {
                        ctx.textAlign = "start";
                        ctx.font = "12px sans-serif";
                        xc = x + event.starttime * ratio + 1;
                        ctx.fillText(text, xc, h);

                        xc += ctx.measureText(text).width;
                        ctx.font = "10px sans-serif";
                        ctx.fillText(ms, xc, h);
                    }

                    h += gapPerEvent;
                });
            };

            this.drawAll = function(width, threshold)
            {
                "use strict";

                width     = width || getContainerWidth();
                threshold = threshold || this.getThreshold();

                var self = this;

                _requests.forEach(function(request) {
                    self.drawOne(request, maxRequestTime, threshold, width);
                });
            };

            this.getThreshold = function() {
                var threshold = Sfjs.getPreference(_storagePrefix + 'threshold');

                if (threshold === null) {
                    return _threshold;
                }

                _threshold = parseInt(threshold);

                return _threshold;
            };

            this.setThreshold = function(threshold)
            {
                _threshold = threshold;

                Sfjs.setPreference(_storagePrefix + 'threshold', threshold);

                return this;
            };
        };

        function canvasAutoUpdateOnResizeAndSubmit(e) {
            e.preventDefault();
            canvasManager.drawAll();
        }

        function canvasAutoUpdateOnThresholdChange(e) {
            canvasManager
                .setThreshold(query('input[name="threshold"]').value)
                .drawAll();
        }

        var requests_data = {
            "max": {{ "%F"|format(collector.events.__section__.endtime) }},
            "requests": [
{{ dump_request_data(token, profile, collector.events, collector.events.__section__.origin) }}

{% if profile.children|length %}
                ,
{% for child in profile.children %}
{{ dump_request_data(child.token, child, child.getcollector('time').events, collector.events.__section__.origin) }}{{ loop.last ? '' : ',' }}
{% endfor %}
{% endif %}
            ]
        };

        var canvasManager = new CanvasManager(requests_data.requests, requests_data.max);

        query('input[name="threshold"]').value = canvasManager.getThreshold();
        canvasManager.drawAll();

        // Update the colors of legends.
        var timelineLegends = document.querySelectorAll('.sf-profiler-timeline > .legends > span[data-color]');

        for (var i = 0; i < timelineLegends.length; ++i) {
            var timelineLegend = timelineLegends[i];

            timelineLegend.style.borderLeftColor = timelineLegend.getAttribute('data-color');
        }

        // Bind event handlers
        var elementTimelineControl  = query('#timeline-control'),
            elementThresholdControl = query('input[name="threshold"]');

        window.onresize                 = canvasAutoUpdateOnResizeAndSubmit;
        elementTimelineControl.onsubmit = canvasAutoUpdateOnResizeAndSubmit;

        elementThresholdControl.onclick  = canvasAutoUpdateOnThresholdChange;
        elementThresholdControl.onchange = canvasAutoUpdateOnThresholdChange;
        elementThresholdControl.onkeyup  = canvasAutoUpdateOnThresholdChange;

        window.setTimeout(function() {
            canvasAutoUpdateOnThresholdChange(null);
        }, 50);

    //]]></script>
{% endblock %}

{% macro dump_request_data(token, profile, events, origin) %}
{% from _self import dump_events %}
                {
                    "id": "{{ token }}",
                    "left": {{ "%F"|format(events.__section__.origin - origin) }},
                    "events": [
{{ dump_events(events) }}
                    ]
                }
{% endmacro %}

{% macro dump_events(events) %}
{% for name, event in events %}
{% if '__section__' != name %}
                        {
                            "name": "{{ name|replace({"\\": "\\\\"}) }}",
                            "category": "{{ event.category }}",
                            "origin": {{ "%F"|format(event.origin) }},
                            "starttime": {{ "%F"|format(event.starttime) }},
                            "endtime": {{ "%F"|format(event.endtime) }},
                            "duration": {{ "%F"|format(event.duration) }},
                            "memory": {{ "%.1F"|format(event.memory / 1024 / 1024) }},
                            "periods": [
                                {%- for period in event.periods -%}
                                    {"start": {{ "%F"|format(period.starttime) }}, "end": {{ "%F"|format(period.endtime) }}}{{ loop.last ? '' : ', ' }}
                                {%- endfor -%}
                            ]
                        }{{ loop.last ? '' : ',' }}
{% endif %}
{% endfor %}
{% endmacro %}

{% macro display_timeline(id, events, colors) %}
    <div class="sf-profiler-timeline">
        <div class="legends">
            {% for category, color in colors %}
                <span data-color="{{ color }}">{{ category }}</span>
            {% endfor %}
        </div>
        <canvas width="680" height="" id="{{ id }}" class="timeline"></canvas>
    </div>
{% endmacro %}
